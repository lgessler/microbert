<html><body><text id="wikipedia_id_wikipedia_org__16237.html" ns="0" revid="21164941" sourceurl="https://id.wikipedia.org/wiki/Protokol_Transfer_Hiperteks" title="Protokol Transfer Hiperteks" type="wikipedia">Protokol Transfer Hiperteks
<p><hi rend="bold">Protokol Transfer Hiperteks</hi> (<hi rend="italic">Hypertext Transfer Protocol</hi>, disingkat <hi rend="bold">HTTP</hi>) adalah <ref target="https://id.wikipedia.org/wiki/Protokol_aplikasi">protokol pada lapisan aplikasi</ref> untuk sistem informasi hypermedia yang terdistribusi dan kolaboratif.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref> HTTP adalah dasar komunikasi data untuk <ref target="https://id.wikipedia.org/wiki/World_Wide_Web">World Wide Web</ref>, di mana dokumen <ref target="https://id.wikipedia.org/wiki/Hiperteks">hiperteks</ref> menyertakan hyperlink ke sumber daya lain yang dapat dengan mudah diakses pengguna, misalnya dengan mengklik <ref target="https://id.wikipedia.org/wiki/Mouse">mouse</ref> atau dengan mengetuk layar di peramban web.</p>
<p>Pengembangan HTTP diprakarsai oleh <ref target="https://id.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</ref> di <ref target="https://id.wikipedia.org/wiki/CERN">CERN</ref> pada tahun 1989. Pengembangan Permintaan HTTP awal untuk Komentar (RFC) adalah upaya terkoordinasi oleh <ref target="https://id.wikipedia.org/wiki/Internet_Engineering_Task_Force">Internet Engineering Task Force</ref> (IETF) dan <ref target="https://id.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium</ref> (W3C), dengan pekerjaan kemudian pindah ke IETF.</p>
<p>HTTP/1.1 pertama kali didokumentasikan dalam <ref target="https://tools.ietf.org/html/rfc2068">RFC 2068</ref> pada tahun 1997. Spesifikasi itu sudah usang oleh <ref target="https://tools.ietf.org/html/rfc2616">RFC 2616</ref> pada tahun 1999, yang juga digantikan oleh keluarga <ref target="https://tools.ietf.org/html/rfc7230">RFC 7230</ref> RFC pada tahun 2014.</p>
<p><ref target="https://id.wikipedia.org/wiki/HTTP/2">HTTP/2</ref> adalah ekspresi semantik HTTP yang lebih efisien "on the wire", dan diterbitkan pada 2015; sekarang didukung oleh hampir semua peramban web<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-2">[2]</ref> dan server web utama melalui <ref target="https://id.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</ref> (TLS) menggunakan ekstensi  <ref target="https://id.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">Application-Layer Protocol Negotiation</ref> (ALPN)<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-3">[3]</ref> di mana diperlukan <ref target="https://id.wikipedia.org/wiki/Transport_Layer_Security">TLS 1.2</ref> atau yang lebih baru.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-4">[4]</ref></p>
<p><ref target="https://id.wikipedia.org/wiki/HTTP/3">HTTP/3</ref> adalah penerus yang diusulkan untuk HTTP/2,<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-5">[5]</ref> yang sudah digunakan di web, menggunakan <ref target="https://id.wikipedia.org/wiki/Udp">UDP</ref> bukan <ref target="https://id.wikipedia.org/wiki/TCP">TCP</ref> untuk protokol transportasi yang mendasarinya. Seperti HTTP/2, protokol ini tidak ketinggalan versi utama sebelumnya. Dukungan untuk HTTP/ 3 ditambahkan ke <ref target="https://id.wikipedia.org/wiki/Cloudflare">Cloudflare</ref> dan <ref target="https://id.wikipedia.org/wiki/Google_Chrome">Google Chrome</ref> pada September 2019,<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-6">[6]</ref> dan dapat diaktifkan di versi stabil Chrome dan Firefox.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-7">[7]</ref></p>
Gambaran teknikal
<figure><caption><ref target="https://id.wikipedia.org/wiki/URL">URL</ref> dimulai dengan skema HTTP dan label nama domain <ref target="https://id.wikipedia.org/wiki/WWW">WWW</ref></caption></figure>
<p>HTTP berfungsi sebagai protokol <ref target="https://id.wikipedia.org/wiki/Permintaan-respon">permintaan-respons</ref> dalam model komputasi klien-server. <ref target="https://id.wikipedia.org/wiki/Peramban_web">Peramban web</ref>, misalnya, mungkin <hi rend="italic">klien</hi> dan aplikasi yang berjalan di komputer yang meng-<ref target="https://id.wikipedia.org/wiki/Host_(jaringan)">hosting</ref> <ref target="https://id.wikipedia.org/wiki/Situs_web">situs web</ref> mungkin adalah <hi rend="italic">server</hi>. Klien mengirimkan pesan permintaan HTTP ke server. Server, yang menyediakan <hi rend="italic">sumber daya</hi> seperti file <ref target="https://id.wikipedia.org/wiki/HTML">HTML</ref> dan konten lainnya, atau melakukan fungsi lain atas nama klien, mengembalikan pesan <hi rend="italic">respons</hi> ke klien. Respons tersebut berisi informasi status penyelesaian tentang permintaan dan mungkin juga berisi konten yang diminta di badan pesannya.</p>
<p>Peramban web adalah contoh <hi rend="italic"><ref target="https://id.wikipedia.org/wiki/User_agent">user agent</ref></hi> (UA). Jenis lain dari agen pengguna termasuk perangkat lunak pengindeksan yang digunakan oleh penyedia pencarian (<ref target="https://id.wikipedia.org/wiki/Perayap_web">perayap web</ref>), <ref target="https://id.wikipedia.org/wiki/Peramban_suara">peramban suara</ref>, <ref target="https://id.wikipedia.org/wiki/Aplikasi_seluler">aplikasi seluler</ref>, dan <ref target="https://id.wikipedia.org/wiki/Perangkat_lunak">perangkat lunak</ref> lain yang mengakses, menggunakan, atau menampilkan konten web.</p>
<p>HTTP dirancang untuk mengizinkan elemen jaringan perantara untuk meningkatkan atau mengaktifkan komunikasi antara klien dan server. Situs web dengan lalu lintas tinggi sering kali mendapatkan keuntungan dari server <ref target="https://id.wikipedia.org/wiki/Tembolok_web">cache web</ref> yang mengirimkan konten atas nama <ref target="https://id.wikipedia.org/wiki/Server_upstream">server hulu</ref> untuk meningkatkan waktu respon. Tembolok peramban web sebelumnya mengakses sumber daya web dan menggunakannya kembali, jika memungkinkan, untuk mengurangi lalu lintas jaringan. <ref target="https://id.wikipedia.org/wiki/Server_proxy">Server proxy</ref> HTTP pada batas <ref target="https://id.wikipedia.org/wiki/Jaringan_pribadi">jaringan pribadi</ref> dapat memfasilitasi komunikasi untuk klien tanpa alamat yang dapat dirutekan secara global, dengan menyampaikan pesan dengan server eksternal.</p>
<p><ref target="https://id.wikipedia.org/wiki/Sumber_daya_web">Sumber daya HTTP</ref> diidentifikasi dan ditempatkan di jaringan oleh <ref target="https://id.wikipedia.org/wiki/Url">Uniform Resource Locators</ref> (URL), menggunakan skema <hi rend="italic">http</hi> dan <hi rend="italic"><ref target="https://id.wikipedia.org/wiki/Https">https</ref></hi> <ref target="https://id.wikipedia.org/wiki/Pengidentifikasi_sumber_seragam">Uniform Resource Identifiers</ref> (URI). Seperti yang didefinisikan dalam <ref target="https://tools.ietf.org/html/rfc3986">RFC 3986</ref>, URI dikodekan sebagai <ref target="https://id.wikipedia.org/wiki/Hyperlink">hyperlink</ref> dalam dokumen <ref target="https://id.wikipedia.org/wiki/HTML">HTML</ref>, sehingga dapat membentuk dokumen hypertext yang saling terkait.</p>
Sejarah
<figure><caption><ref target="https://id.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</ref></caption></figure>
<p>Istilah <ref target="https://id.wikipedia.org/wiki/Hypertext">hypertext</ref> diciptakan oleh <ref target="https://id.wikipedia.org/wiki/Ted_Nelson">Ted Nelson</ref> pada tahun 1965 di <ref target="https://id.wikipedia.org/wiki/Proyek_Xanadu">Proyek Xanadu</ref>, yang pada gilirannya terinspirasi oleh visi 1930-an <ref target="https://id.wikipedia.org/wiki/Vannevar_Bush">Vannevar Bush</ref> tentang pengambilan informasi berbasis mikrofilm dan sistem "<ref target="https://id.wikipedia.org/wiki/Memex">memex</ref>" manajemen yang dijelaskan dalam esai 1945-nya "<ref target="https://id.wikipedia.org/wiki/As_We_May_Think">As We May Think</ref>". <ref target="https://id.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</ref> dan timnya di <ref target="https://id.wikipedia.org/wiki/CERN">CERN</ref> dikreditkan dengan menciptakan HTTP asli, bersama dengan HTML dan teknologi terkait untuk server web dan browser web berbasis teks. Berners-Lee pertama kali mengusulkan proyek "WorldWideWeb" pada tahun 1989 - sekarang dikenal sebagai <ref target="https://id.wikipedia.org/wiki/World_Wide_Web">World Wide Web</ref>. Versi pertama protokol hanya memiliki satu metode, yaitu GET, yang akan meminta halaman dari server.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-8">[8]</ref> Respons dari server selalu berupa halaman HTML.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-9">[9]</ref></p>
<p>Versi HTTP terdokumentasi pertama adalah <hi rend="bold"><ref target="https://www.w3.org/pub/WWW/Protocols/HTTP/AsImplemented.html">HTTP V0.9</ref></hi> (1991). <ref target="https://id.wikipedia.org/wiki/Dave_Raggett">Dave Raggett</ref> memimpin Kelompok Kerja HTTP (HTTP WG) pada tahun 1995 dan ingin memperluas protokol dengan operasi yang diperpanjang, negosiasi yang lebih luas, meta-informasi yang lebih kaya, diikat dengan protokol keamanan yang menjadi lebih efisien dengan menambahkan metode tambahan dan <ref target="https://id.wikipedia.org/wiki/Bidang_header">bidang header</ref>.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-10">[10]</ref> <ref target="https://tools.ietf.org/html/rfc1945">RFC 1945</ref> secara resmi memperkenalkan dan mengakui HTTP V1.0 pada tahun 1996.</p>
<p>Pada tahun 2007, <ref target="https://httpwg.org/"><hi rend="bold">Kelompok Kerja HTTP</hi></ref> dibentuk, sebagian, untuk merevisi dan mengklarifikasi spesifikasi HTTP/1.1. Pada Juni 2014, WG merilis spesifikasi enam bagian yang diperbarui <ref target="https://tools.ietf.org/html/rfc2616">RFC 2616</ref> yang sudah usang:</p>
<list type="unordered"><item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7230">7230</ref>, <hi rend="italic">HTTP/1.1: Sintaks dan Routing Pesan</hi></item>
<item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7231">7231</ref>, <hi rend="italic">HTTP/1.1: Semantik dan Konten</hi></item>
<item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7232">7232</ref>, <hi rend="italic">HTTP/1.1: Permintaan Bersyarat</hi></item>
<item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7233">7233</ref>, <hi rend="italic">HTTP/1.1: Rentang Permintaan</hi></item>
<item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7234">7234</ref>, <hi rend="italic">HTTP/1.1: Caching</hi></item>
<item><ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7235">7235</ref>, <hi rend="italic">HTTP/1.1: Autentikasi</hi></item></list>
<p><ref target="https://id.wikipedia.org/wiki/HTTP/2">HTTP/2</ref> diterbitkan sebagai <ref target="https://id.wikipedia.org/wiki/Request_for_Comments_(identifier)">RFC</ref><ref target="https://tools.ietf.org/html/rfc7540">7540</ref> pada Mei 2015.</p>

Sesi HTTP
<p>Sesi HTTP adalah urutan transaksi respons-permintaan jaringan. Klien HTTP memulai permintaan dengan membuat koneksi <ref target="https://id.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</ref> (TCP) ke <ref target="https://id.wikipedia.org/wiki/Port_(Jaringan_Komputer)">port</ref> tertentu pada server (biasanya port 80, terkadang port 8080; lihat <ref target="https://id.wikipedia.org/wiki/Daftar_nomor_port_TCP_dan_UDP">Daftar nomor port TCP dan UDP</ref>). Server HTTP yang mendengarkan port itu menunggu pesan permintaan klien. Setelah menerima permintaan, server mengirim kembali baris status, seperti "HTTP/1.1 200 OK", dan pesannya sendiri. Isi pesan ini biasanya adalah sumber yang diminta, meskipun pesan kesalahan atau informasi lain juga dapat dikembalikan.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref></p>
Koneksi persisten
<p>Dalam HTTP/0.9 dan 1.0, koneksi ditutup setelah satu pasangan permintaan / respons. Dalam HTTP/1.1 mekanisme keep-hidup diperkenalkan, di mana koneksi dapat digunakan kembali untuk lebih dari satu permintaan. <hi rend="italic">Koneksi persisten</hi> seperti itu mengurangi <ref target="https://id.wikipedia.org/wiki/Latensi_(teknik)">latensi</ref> permintaan dengan jelas, karena klien tidak perlu menegosiasikan kembali koneksi TCP 3-Way-Handshake setelah permintaan pertama dikirim. Efek samping positif lainnya adalah, secara umum, koneksi menjadi lebih cepat seiring berjalannya waktu karena mekanisme <ref target="https://id.wikipedia.org/wiki/TCP_congestion_control#Slow_start">slow-start</ref>-TCP.</p>
<p>Versi 1.1 protokol juga membuat peningkatan optimasi bandwidth ke HTTP/1.0. Misalnya, HTTP/1.1 memperkenalkan <ref target="https://id.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</ref> untuk memungkinkan konten pada koneksi yang persisten di-stream daripada buffer. <ref target="https://id.wikipedia.org/wiki/Perpipaan_HTTP">Perpipaan HTTP</ref> lebih lanjut mengurangi waktu jeda, memungkinkan klien untuk mengirim beberapa permintaan sebelum menunggu setiap tanggapan. Tambahan lain untuk protokol adalah <ref target="https://id.wikipedia.org/wiki/Byte_serving">byte serving</ref>, di mana server mentransmisikan hanya sebagian dari sumber daya yang secara eksplisit diminta oleh klien.</p>
Status sesi HTTP
<p>HTTP adalah <ref target="https://id.wikipedia.org/wiki/Stateless_protocol">stateless protocol</ref>. Stateless protocol tidak memerlukan <ref target="https://id.wikipedia.org/wiki/Server_web">server HTTP</ref> untuk menyimpan informasi atau status tentang setiap pengguna selama beberapa permintaan. Namun, beberapa <ref target="https://id.wikipedia.org/wiki/Aplikasi_web">aplikasi web</ref> menerapkan independen atau <ref target="https://id.wikipedia.org/wiki/Sesi_(ilmu_komputer)">sesi sisi server</ref> semenggunakan misalnya <ref target="https://id.wikipedia.org/wiki/Cookie_HTTP">cookie HTTP</ref> atau <ref target="https://id.wikipedia.org/wiki/Variabel_(ilmu_komputer)">variabel</ref> tersembunyi dalam <ref target="https://id.wikipedia.org/wiki/Formulir_(HTML)">formulir web</ref>.</p>
Autentikasi HTTP
<p>HTTP menyediakan beberapa skema otentikasi seperti <ref target="https://id.wikipedia.org/wiki/Otentikasi_akses_dasar">otentikasi akses dasar</ref> dan <ref target="https://id.wikipedia.org/wiki/Intisari_akses_otentikasi">intisari akses otentikasi</ref> yang beroperasi melalui mekanisme respons-respons di mana server mengidentifikasi dan mengeluarkan tantangan sebelum menyajikan konten yang diminta.</p>
<p>HTTP menyediakan kerangka kerja umum untuk kontrol akses dan otentikasi, melalui serangkaian skema otentikasi respons-responsif, yang dapat digunakan oleh server untuk menantang permintaan klien dan oleh klien untuk memberikan informasi otentikasi.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:0-11">[11]</ref></p>
Alam autentikasi
<p>Spesifikasi Otentikasi HTTP juga menyediakan konstruksi sewenang-wenang, spesifik implementasi untuk membagi lebih lanjut sumber daya yang umum untuk <ref target="https://id.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</ref> root yang diberikan. String nilai ranah, jika ada, dikombinasikan dengan URI akar kanonik untuk membentuk komponen ruang perlindungan dari tantangan. Ini berlaku memungkinkan server untuk menentukan cakupan otentikasi terpisah di bawah satu URI root.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:0-11">[11]</ref>bocor</p>
Format pesan
<p>Klien mengirim <hi rend="bold">permintaan</hi> ke server dan server mengirim <hi rend="bold">tanggapan</hi>.</p>
Permintaan pesan
<figure><caption>Permintaan HTTP 1.1 dibuat menggunakan telnet. Pesan <ref target="https://id.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Permintaan_pesan">permintaan</ref>, bagian tajuk <ref target="https://id.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Pesan_tanggapan">respons</ref>, dan badan respons disorot.</caption></figure>
<p>Pesan permintaan terdiri dari:</p>
<list type="unordered"><item>baris permintaan (mis., <hi rend="italic">GET /images/logo.png HTTP / 1.1</hi>, yang meminta sumber daya yang disebut /images/logo.png dari server)</item>
<item>bidang tajuk permintaan (mis., <hi rend="italic">Bahasa Terima: id</hi>)</item>
<item>garis kosong</item>
<item><ref target="https://id.wikipedia.org/wiki/Badan_pesan_HTTP">badan pesan</ref> opsional</item></list>
<p>Baris permintaan dan bidang tajuk lainnya masing-masing harus diakhiri dengan &lt;CR&gt; &lt;LF&gt; (yaitu, karakter <ref target="https://id.wikipedia.org/wiki/Carriage_return">carriage return</ref> diikuti oleh karakter umpan baris). Baris kosong harus terdiri dari hanya &lt;CR&gt; &lt;LF&gt; dan tidak ada <ref target="https://id.wikipedia.org/wiki/Karakter_spasi_putih">spasi putih</ref> lainnya.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref> Dalam protokol HTTP/1.1, semua bidang tajuk kecuali <hi rend="italic">Host</hi> adalah opsional.</p>
<p>Baris permintaan yang hanya berisi nama jalur diterima oleh server untuk menjaga kompatibilitas dengan klien HTTP sebelum spesifikasi HTTP/1.0 dalam <ref target="https://tools.ietf.org/html/rfc1945">RFC 1945</ref><ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-12">[12]</ref></p>
Metode permintaan
<p>HTTP mendefinisikan metode (kadang-kadang disebut sebagai kata kerja, tetapi tidak ada dalam spesifikasi yang menyebutkan kata kerja, juga OPTIONS atau HEAD kata kerja) untuk menunjukkan tindakan yang diinginkan untuk dilakukan pada sumber daya yang diidentifikasi. Sumber daya ini mewakili, apakah data yang sudah ada sebelumnya atau data yang dihasilkan secara dinamis, tergantung pada implementasi server. Seringkali, sumber daya berhubungan dengan file atau output dari executable yang berada di server. Spesifikasi HTTP/1.0<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-13">[13]</ref> mendefinisikan metode GET, HEAD dan POST dan spesifikasi HTTP/1.1<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref> menambahkan lima metode baru: OPTIONS, PUT, DELETE, TRACE , dan CONNECT.</p>
HEADMetode HEAD meminta respons yang identik dengan permintaan GET, tetapi tanpa badan respons. Ini berguna untuk mengambil meta-informasi yang ditulis di header respons, tanpa harus mengangkut seluruh konten.
GETMeminta representasi sumber tertentu. Permintaan menggunakan GET (dan beberapa metode HTTP lain) "tidak boleh memiliki kepentingan melakukan tindakan selain <ref target="https://id.wikipedia.org/wiki/Pengaksesan_data">pengaksesan</ref>". <ref target="https://id.wikipedia.org/wiki/W3C">W3C</ref> telah menerbitkan prinsip panduan mengenai perbedaan ini dengan menyatakan, "desain <ref target="https://id.wikipedia.org/wiki/Aplikasi_web">aplikasi web</ref> harus mematuhi prinsip di atas, serta batasan sejenis."<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-14">[14]</ref>
POST<ref target="https://id.wikipedia.org/wiki/POST_(HTTP)">Metode POST</ref> meminta server menerima entitas yang terlampir dalam permintaan sebagai bawahan baru sumber daya web yang diidentifikasi oleh URI. Data POSTed mungkin, misalnya, anotasi untuk sumber daya yang ada; pesan untuk papan buletin, newsgroup, milis, atau utas komentar; blok data yang merupakan hasil dari mengirimkan formulir web ke proses penanganan data; atau item untuk ditambahkan ke database.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref>
PUTMetode PUT meminta entitas terlampir disimpan di bawah <ref target="https://id.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</ref> yang disediakan. Jika URI mengacu pada sumber daya yang sudah ada, itu diubah; jika URI tidak menunjuk ke sumber daya yang ada, maka server dapat membuat sumber daya dengan URI itu.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref>
DELETEMetode DELETE menghapus sumber daya yang ditentukan.
TRACEMetode TRACE menggemakan permintaan yang diterima sehingga klien dapat melihat apa (jika ada) perubahan atau penambahan yang telah dilakukan oleh server perantara.
OPTIONSMetode OPTIONS mengembalikan metode HTTP yang didukung server untuk <ref target="https://id.wikipedia.org/wiki/URL">URL</ref> yang ditentukan. Ini dapat digunakan untuk memeriksa fungsionalitas server web dengan meminta '*' alih-alih sumber daya tertentu.
CONNECT<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref> Metode CONNECT mengubah koneksi permintaan ke <ref target="https://id.wikipedia.org/wiki/Protokol_Tunneling">terowongan TCP / IP</ref> transparan, biasanya untuk memfasilitasi komunikasi terenkripsi <ref target="https://id.wikipedia.org/wiki/TLS">SSL</ref> (HTTPS) melalui proxy HTTP yang tidak terenkripsi.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-15">[15]</ref> Lihat <ref target="https://id.wikipedia.org/wiki/Terowongan_HTTP#Metode_HTTP_CONNECT">metode HTTP CONNECT</ref>.
PATCHMetode PATCH menerapkan modifikasi parsial ke sumber daya.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-16">[16]</ref>
<p>Semua server HTTP tujuan umum wajib menerapkan setidaknya metode GET dan HEAD, dan semua metode lain dianggap opsional oleh spesifikasi.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-:1-1">[1]</ref></p>
Keamanan
<p>Metode TRACE dapat digunakan sebagai bagian dari kelas serangan yang dikenal sebagai <ref target="https://id.wikipedia.org/wiki/Cross-site_tracing">cross-site tracing</ref>; untuk alasan itu, saran keamanan umum adalah agar dinonaktifkan di konfigurasi server.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-OWASP-XST-17">[17]</ref> Microsoft <ref target="https://id.wikipedia.org/wiki/IIS">IIS</ref> mendukung metode "TRACK", yang berperilaku sama, dan yang juga direkomendasikan untuk dinonaktifkan.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-OWASP-XST-17">[17]</ref></p>

Respon pesan
<p>Pesan respons terdiri dari berikut ini:</p>
<list type="unordered"><item>baris status yang mencakup <ref target="https://id.wikipedia.org/wiki/Daftar_kode_status_HTTP">kode status</ref> dan pesan alasan (e.g., <hi rend="italic">HTTP/1.1 200 OK</hi>, yang mengindikasikan bahwa permintaan klien berhasil)</item>
<item><ref target="https://id.wikipedia.org/wiki/Daftar_bidang_header_HTTP#Bidang_respons">bidang header respons</ref> (mis., <hi rend="italic">Content-Type: text/html</hi>)</item>
<item>Sebuah garis kosong</item>
<item>Sebuah <ref target="https://id.wikipedia.org/wiki/HTTP_message_body">message body</ref> opsional</item></list>
<p>Baris status dan bidang header lainnya harus diakhiri dengan &lt;CR&gt;&lt;LF&gt;. Baris kosong harus terdiri dari hanya &lt;CR&gt;&lt;LF&gt; dan tidak ada <ref target="https://id.wikipedia.org/wiki/Karakter_spasi">spasi putih</ref> lainnya.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-ietf2616sec4-18">[18]</ref> Persyaratan ketat ini untuk &lt;CR&gt;&lt;LF&gt; adalah berelaksi dalam badan pesan untuk penggunaan konsisten dari linebreak sistem lain seperti &lt;CR&gt; atau &lt;LF&gt; saja.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-19">[19]</ref></p>
Kode status
Lihat pula: <ref target="https://id.wikipedia.org/wiki/Daftar_kode_status_HTTP">Daftar kode status HTTP</ref><p>Dalam HTTP/1.0 dan sejak itu, baris pertama dari respons HTTP disebut <hi rend="italic">baris status</hi> dan termasuk <hi rend="italic">kode status</hi> numerik (seperti "<ref target="https://id.wikipedia.org/wiki/HTTP_404">404</ref>") dan frase <hi rend="italic">alasan</hi> tekstual (seperti "Not Found"). Cara <ref target="https://id.wikipedia.org/wiki/Agen_pengguna">agen pengguna</ref> menangani respons bergantung terutama pada kode, dan yang kedua pada bidang header respons lainnya. Kode status khusus dapat digunakan, karena jika agen pengguna menemukan kode yang tidak dikenali, ia dapat menggunakan digit pertama dari kode untuk menentukan kelas umum dari respons.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-20">[20]</ref></p>
<p><hi rend="italic">Ungkapan alasan</hi> standar hanya rekomendasi, dan dapat diganti dengan "setara lokal" atas kebijakan <ref target="https://id.wikipedia.org/wiki/Pengembang_web">pengembang web</ref>. Jika kode status menunjukkan masalah, agen pengguna mungkin menampilkan <hi rend="italic">frasa alasan</hi> kepada pengguna untuk memberikan informasi lebih lanjut tentang sifat masalah. Standar juga memungkinkan agen pengguna untuk mencoba menafsirkan frasa alasan, meskipun ini mungkin tidak bijaksana karena standar secara eksplisit menentukan bahwa kode status dapat dibaca mesin dan <hi rend="italic">frasa alasan</hi> dapat dibaca oleh manusia. Kode status HTTP terutama dibagi menjadi lima kelompok untuk penjelasan permintaan dan tanggapan yang lebih baik antara klien dan server seperti yang disebutkan:</p>
<list type="unordered"><item>Informational 1XX</item>
<item>Berhasil 2XX</item>
<item>Pengalihan 3XX</item>
<item>Klien Error 4XX</item>
<item>Server Error 5XX</item></list>
Koneksi terenkripsi
<p>Cara paling populer untuk membangun koneksi HTTP terenkripsi adalah HTTPS.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-21">[21]</ref> Dua metode lain untuk membuat koneksi HTTP terenkripsi juga ada: <ref target="https://id.wikipedia.org/wiki/Secure_Hypertext_Transfer_Protocol">Secure Hypertext Transfer Protocol</ref>, dan menggunakan <ref target="https://id.wikipedia.org/wiki/Header_Upgrade_HTTP/1.1">header Upgrade HTTP/1.1</ref> untuk menentukan peningkatan ke TLS. Dukungan browser untuk keduanya, bagaimanapun, hampir tidak ada.<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-22">[22]</ref><ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-23">[23]</ref></p>
Contoh sesi
<p>Di bawah ini adalah contoh percakapan antara klien HTTP dan server HTTP yang berjalan di <ref target="https://id.wikipedia.org/wiki/Www.example.com">www.example.com</ref>, port 80.</p>
Permintaan klien
GET / HTTP/1.1
Host: www.example.com
<p>Permintaan klien (terdiri dalam kasus ini dari garis permintaan dan hanya satu bidang tajuk) diikuti oleh garis kosong, sehingga permintaan berakhir dengan dua baris baru, masing-masing dalam bentuk <ref target="https://id.wikipedia.org/wiki/Carriage_return">carriage return</ref> diikuti oleh <ref target="https://id.wikipedia.org/wiki/Garis_baru">umpan baris</ref>. Bidang "Host" membedakan antara berbagai nama <ref target="https://id.wikipedia.org/wiki/DNS">DNS</ref> yang berbagi <ref target="https://id.wikipedia.org/wiki/Alamat_IP">alamat IP</ref> tunggal, yang memungkinkan <ref target="https://id.wikipedia.org/wiki/Hosting_virtual">hosting virtual</ref> berbasis nama. Sementara opsional dalam HTTP/1.0, itu wajib di HTTP/1.1. ("/" Berarti /index.html jika ada.)</p>
Respon server
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 155
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: "3f80f-1b6-3e1cb03b"
Accept-Ranges: bytes
Connection: close

&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;An Example Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
<p>Bidang header <ref target="https://id.wikipedia.org/wiki/HTTP_ETag">ETag</ref> (tag entitas) digunakan untuk menentukan apakah versi cache dari sumber daya yang diminta identik dengan versi sumber daya saat ini di server. <hi rend="italic">Content-Type</hi> menentukan <ref target="https://id.wikipedia.org/wiki/Tipe_media">jenis media Internet</ref> dari data yang disampaikan oleh pesan HTTP, sementara <hi rend="italic">Content-Length</hi> menunjukkan panjangnya dalam byte. <ref target="https://id.wikipedia.org/wiki/Server_web">Server web</ref> HTTP / 1.1 menerbitkan kemampuannya untuk menanggapi permintaan untuk rentang bita tertentu dari dokumen dengan mengatur bidang <hi rend="italic">Accept-Ranges: bytes</hi>. Ini berguna, jika klien hanya perlu memiliki porsi tertentu<ref target="https://id.wikipedia.org/wiki/Halaman_Utama#cite_note-24">[24]</ref> dari sumber daya yang dikirim oleh server, yang disebut <ref target="https://id.wikipedia.org/wiki/Byte_serving">byte serving</ref>. Ketika <hi rend="italic">Connection: close</hi> dikirim, itu berarti bahwa <ref target="https://id.wikipedia.org/wiki/Server_web">server web</ref> akan menutup koneksi <ref target="https://id.wikipedia.org/wiki/TCP">TCP</ref> segera setelah transfer tanggapan ini.</p>
<p>Sebagian besar baris header adalah opsional. Ketika <hi rend="italic">Content-Length</hi> menghilang panjang ditentukan dengan cara lain. Pengkodean transfer chunked menggunakan ukuran chunk 0 untuk menandai akhir konten. Pengodean <hi rend="italic">identitas</hi> tanpa <hi rend="italic">Content-Length</hi>  membaca konten sampai soket ditutup.</p>
<p><hi rend="italic">Content-Encoding</hi> seperti <hi rend="italic"><ref target="https://id.wikipedia.org/wiki/Gzip">gzip</ref></hi> dapat digunakan untuk mengompresi data yang dikirimkan.</p>
Protokol serupa
<list type="unordered"><item><ref target="https://id.wikipedia.org/wiki/Gopher_(protokol)">Protokol Gopher</ref> adalah protokol pengiriman konten yang digantikan oleh HTTP pada awal 1990-an.</item>
<item>Protokol <ref target="https://id.wikipedia.org/wiki/SPDY">SPDY</ref> adalah alternatif untuk HTTP yang dikembangkan di <ref target="https://id.wikipedia.org/wiki/Google">Google</ref>, digantikan oleh <ref target="https://id.wikipedia.org/wiki/HTTP/2">HTTP/2</ref>.</item></list>
Lihat pula
<list type="unordered"><item><ref target="https://id.wikipedia.org/wiki/Fiddler_(perangkat_lunak)">Fiddler (perangkat lunak)</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/Kompresi_HTTP">Kompresi HTTP</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/Daftar_kode_status_HTTP">Daftar kode status HTTP</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/Objek_varian">Objek varian</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/Temblok_web">Temblok web</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/WebSocket">WebSocket</ref></item>
<item><ref target="https://id.wikipedia.org/wiki/Wireshark">Wireshark</ref></item></list>


Pranala luar

<list type="unordered"><item>"<ref target="https://www.w3.org/Protocols/History.html">Change History for HTTP</ref>".  Sejarah teknis rinci HTTP.</item>
<item>"<ref target="https://www.w3.org/Protocols/DesignIssues.html">Design Issues for HTTP</ref>". Masalah Desain oleh Berners-Lee ketika dia merancang protokol.</item>
<item><ref target="http://www.indowebspace.com">Pembelian domain</ref></item>
<item>"<ref target="https://www.w3.org/Protocols/Classic.html">Classic HTTP Documents</ref>".daftar dokumen klasik lainnya yang menceritakan sejarah protokol awal</item>
<item><ref target="https://www.w3.org/Protocols/HTTP/AsImplemented.html">HTTP 0.9 – Sebagaimana Diterapkan pada 1991</ref></item></list>
</text></body></html>